% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1.1.f.data.prep.R
\name{polyCB}
\alias{polyCB}
\title{Create minimum convex polygon based on coordinates of species occurence data for several species}
\usage{
polyCB(spp.occ.list, k = 1, c.m = "AP", r = 2, q = 0.3,
  distance = "euclidean", min.nc = 2, max.nc = 20,
  method = "mcquitty", index = "all", alphaBeale = 0.1, convex = T,
  alpha = 10, plot = T, save = T, save.pts = F, numCores = 1,
  crs.set = "+proj=longlat +datum=WGS84")
}
\arguments{
\item{spp.occ.list}{A named list of species occurence points, either as "data.frame" or "SpatialPoints"/"SpatialPointsDataFrame"}

\item{k}{number of polygons to create based on coordinates}

\item{c.m}{clustering method to find the best number of clusters (k). Currently E (Elbow) or (Affinity Propagation).}

\item{r}{exponent (see details below)}

\item{q}{if \code{p=NA}, exemplar preferences are initialized
    according to the distribution of non-Inf values in \code{s}.
    If \code{q=NA}, exemplar preferences are set to the median
    of non-Inf values in \code{s}. If \code{q} is a value
    between 0 and 1, the sample quantile with threshold
    \code{q} is used, whereas \code{q=0.5} again results in
    the median.}

\item{distance}{the distance measure to be used to compute the dissimilarity matrix. This must be one of: "euclidean", "maximum", "manhattan", "canberra", "binary", "minkowski" or "NULL". By default, distance="euclidean". 
If the distance is "NULL", the dissimilarity matrix (diss) should be given by the user. If distance is not "NULL", the dissimilarity matrix should be "NULL".}

\item{min.nc}{minimal number of clusters, between 1  and (number of objects - 1)}

\item{max.nc}{maximal number of clusters, between 2 and (number of objects - 1), greater or equal to min.nc. By default, max.nc=15.}

\item{method}{type of distance measure to be used; for \code{negDistMat},
    \code{expSimMat} and \code{linSimMat}, this argument is analogous to the
    \code{method} argument of \code{\link[stats:dist]{dist}}.
    For \code{corSimMat}, this argument is analogous to the \code{method}
    argument of \code{\link[stats:cor]{cor}}.}

\item{index}{the index to be calculated. This should be one of : "kl", "ch", "hartigan", "ccc", "scott", "marriot", "trcovw", "tracew", "friedman",  "rubin", "cindex",  "db", "silhouette", "duda", "pseudot2", "beale",  "ratkowsky", "ball", "ptbiserial", "gap", "frey", "mcclain", "gamma", "gplus", "tau", "dunn", "hubert", "sdindex", "dindex", "sdbw", "all" (all indices except GAP, Gamma, Gplus and Tau), "alllong" (all indices with Gap, Gamma, Gplus and Tau included).}

\item{alphaBeale}{significance value for Beale's index.}

\item{convex}{Logical. Convex (T) or concave (F) polygon}

\item{alpha}{Value of \eqn{\alpha}.}

\item{plot}{logical. Plot results or not?}

\item{save}{Should save polygons on disk?}

\item{save.pts}{logical. Save each species' occurence points as shapefile?}

\item{numCores}{Number of cores to use for parallelization. If set to 1, no paralellization is performed}

\item{crs.set}{set the coordinate reference system (CRS) of the polygons}
}
\description{
This function will use a list of coordinates of species occurence data and create minimum convex polygons
for each element in the list.
It is possible to create concave or convex polygons, create several small polygons based on clusters
of points.
}
\examples{
Bvarieg.occ <- read.table(paste(system.file(package="dismo"),
 "/ex/bradypus.csv", sep=""), header=TRUE, sep=",")
colnames(Bvarieg.occ) <- c("SPEC", "LONG", "LAT")
spp.occ.list <- list(Bvarieg = Bvarieg.occ)
occ.polys <- polyCB(spp.occ.list)
occ.polys <- polyCB(spp.occ.list, convex=TRUE, alpha=10)
}
\seealso{
\code{\link{polyC}}, \code{\link{polySplt}}, \code{\link[NbClust]{NbClust}}
#' @return A named list of spatial polygons built using coordinates
}
